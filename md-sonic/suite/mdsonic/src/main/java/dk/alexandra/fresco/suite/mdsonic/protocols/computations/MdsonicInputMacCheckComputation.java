package dk.alexandra.fresco.suite.mdsonic.protocols.computations;import dk.alexandra.fresco.commitment.HashBasedCommitment;import dk.alexandra.fresco.commitment.HashBasedCommitmentSerializer;import dk.alexandra.fresco.framework.DRes;import dk.alexandra.fresco.framework.MaliciousException;import dk.alexandra.fresco.framework.builder.Computation;import dk.alexandra.fresco.framework.builder.numeric.ProtocolBuilderNumeric;import dk.alexandra.fresco.framework.network.serializers.ByteSerializer;import dk.alexandra.fresco.framework.util.AesCtrDrbg;import dk.alexandra.fresco.framework.util.Drbg;import dk.alexandra.fresco.framework.util.Pair;import dk.alexandra.fresco.framework.value.OInt;import dk.alexandra.fresco.framework.value.SInt;import dk.alexandra.fresco.suite.mdsonic.datatypes.*;import dk.alexandra.fresco.suite.mdsonic.protocols.natives.MdsonicCompZProtocol;import dk.alexandra.fresco.suite.mdsonic.util.UIntSerializer;import java.util.ArrayList;import java.util.List;import java.util.function.Function;import java.util.stream.Collectors;/** * Computation for performing batched mac-check on all currently opened, unchecked values. */public class MdsonicInputMacCheckComputation<PlainT extends MdsonicCompUInt<?, ?, PlainT>>    implements Computation<Void, ProtocolBuilderNumeric> {  private final ByteSerializer<PlainT> serializer;  private final MdsonicCompUIntFactory<PlainT> factory;  private final List<DRes<SInt>> authenticatedElements;  // ASS  private final PlainT openValue;  private final byte[] seed;  // 32 byte  private ByteSerializer<HashBasedCommitment> commitmentSerializer;  private final int noOfParties;  private final Drbg localDrbg;  private final Function<byte[], Drbg> jointDrbgSupplier;  /**   * Creates new {@link MdsonicInputMacCheckComputation}.   *   * @param toCheck authenticated elements and open values that must be checked   */  public MdsonicInputMacCheckComputation(Pair<List<DRes<SInt>>, PlainT> toCheck, byte[] seed, int noOfParties,                                         MdsonicCompUIntFactory<PlainT> factory) {    this.authenticatedElements = toCheck.getFirst();    this.openValue = toCheck.getSecond();    this.seed = seed;    this.factory = factory;    this.serializer = new UIntSerializer<>(factory);    this.commitmentSerializer = new HashBasedCommitmentSerializer();    this.noOfParties = noOfParties;    this.localDrbg = new AesCtrDrbg();    this.jointDrbgSupplier = AesCtrDrbg::new;  }  @Override  public DRes<Void> buildComputation(ProtocolBuilderNumeric builder) {    Drbg jointDrbg = jointDrbgSupplier.apply(seed);    List<PlainT> randomCoefficients = sampleCoefficients(jointDrbg, factory, authenticatedElements.size());    List<PlainT> macShares = authenticatedElements.stream()            .map(factory::toMdsonicASIntArithmetic)            .map(MdsonicASIntArithmetic::getMacShare)            .collect(Collectors.toList());    PlainT mj = MdsonicUInt.innerProduct(macShares, randomCoefficients);    return builder.seq((seq) -> {              DRes<OInt> zjOInt = seq.append(new MdsonicCompZProtocol<>(openValue, mj));              byte[] zj = serializer.serialize(factory.fromOInt(zjOInt));              return () -> zj;            }).seq((seq, zj) -> {              return seq.seq(new CommitmentComputationMdsonic(commitmentSerializer, zj, noOfParties, localDrbg));            }).seq((seq, commitZjs) -> {              List<PlainT> elements = serializer.deserializeList(commitZjs);              PlainT sum = MdsonicUInt.sum(elements);              if (!sum.isZero()) {                throw new MaliciousException("Mac check failed");              }              authenticatedElements.clear();              return null;            });  }  /**   * Samples random coefficients for mac-check using joint source of randomness.   * Fixed bug: Invoke coin tossing protocol to get random seed real time.   */  private List<PlainT> sampleCoefficients(Drbg drbg, MdsonicCompUIntFactory<PlainT> factory,      int numCoefficients) {    List<PlainT> randomCoefficients = new ArrayList<>(numCoefficients);    for (int i = 0; i < numCoefficients; i++) {      byte[] bytes = new byte[factory.getHighBitLength() / Byte.SIZE];      drbg.nextBytes(bytes);      randomCoefficients.add(factory.createFromBytes(bytes));    }    return randomCoefficients;  }}