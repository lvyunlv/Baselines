package dk.alexandra.fresco.suite.mdsonic.protocols.computations;import dk.alexandra.fresco.commitment.HashBasedCommitment;import dk.alexandra.fresco.framework.DRes;import dk.alexandra.fresco.framework.MaliciousException;import dk.alexandra.fresco.framework.builder.Computation;import dk.alexandra.fresco.framework.builder.numeric.ProtocolBuilderNumeric;import dk.alexandra.fresco.framework.network.serializers.ByteSerializer;import dk.alexandra.fresco.framework.util.Drbg;import dk.alexandra.fresco.framework.util.Pair;import dk.alexandra.fresco.suite.mdsonic.datatypes.*;import dk.alexandra.fresco.suite.mdsonic.resource.MdsonicResourcePool;import dk.alexandra.fresco.suite.mdsonic.resource.storage.MdsonicDataSupplier;import java.util.ArrayList;import java.util.List;import java.util.function.Function;import java.util.stream.Collectors;/** * Computation for performing batched mac-check on all currently opened, unchecked values. */public class MdsonicArithmeticMacCheckComputation<    HighT extends MdsonicUInt<HighT>,    LowT extends MdsonicUInt<LowT>,    PlainT extends MdsonicCompUInt<HighT, LowT, PlainT>, SecretP extends MdsonicGF<SecretP>>    implements Computation<Void, ProtocolBuilderNumeric> {  private static int COUNT = 0;  private final ByteSerializer<PlainT> serializer;  private final MdsonicDataSupplier<PlainT, SecretP> supplier;  private final MdsonicCompUIntFactory<PlainT> factory;  private final List<MdsonicASIntArithmetic<PlainT>> authenticatedElements;  // ASS  private final List<PlainT> openValues;  private ByteSerializer<HashBasedCommitment> commitmentSerializer;  private final int noOfParties;  private final Drbg localDrbg;  private final Function<byte[], Drbg> jointDrbgSupplier;  private final int drbgByteLength;  /**   * Creates new {@link MdsonicArithmeticMacCheckComputation}.   *   * @param toCheck authenticated elements and open values that must be checked   * @param resourcePool resources for running Spdz2k   */  public MdsonicArithmeticMacCheckComputation(Pair<List<MdsonicASIntArithmetic<PlainT>>, List<PlainT>> toCheck,                                              MdsonicResourcePool<PlainT, SecretP> resourcePool,                                              final Function<byte[], Drbg> jointDrbgSupplier, final int drbgSeedBitLength) {    this.authenticatedElements = toCheck.getFirst();    this.openValues = toCheck.getSecond();    this.serializer = resourcePool.getPlainSerializer();    this.supplier = resourcePool.getDataSupplier();    this.factory = resourcePool.getFactory();    this.commitmentSerializer = resourcePool.getCommitmentSerializer();    this.noOfParties = resourcePool.getNoOfParties();    this.localDrbg = resourcePool.getLocalRandomGenerator();    this.jointDrbgSupplier = jointDrbgSupplier;    this.drbgByteLength = drbgSeedBitLength / 8;  // xx Byte  }  @Override  public DRes<Void> buildComputation(ProtocolBuilderNumeric builder) {    PlainT macKeyShare = supplier.getSecretSharedKey();//    System.out.println("SPDZ2k Mac Check " + COUNT++ + " "+ openValues.size());    return builder            .seq(new CoinTossingComputation(drbgByteLength, commitmentSerializer, noOfParties, localDrbg))            .seq((seq, seed) -> {              Drbg jointDrbg = jointDrbgSupplier.apply(seed);              List<PlainT> randomCoefficients = sampleCoefficients(jointDrbg, factory, openValues.size());              PlainT y = MdsonicUInt.innerProduct(openValues, randomCoefficients);              List<PlainT> macShares = authenticatedElements.stream()                      .map(MdsonicASIntArithmetic::getMacShare)                      .collect(Collectors.toList());              PlainT mj = MdsonicUInt.innerProduct(macShares, randomCoefficients);              PlainT zj = mj.subtract(macKeyShare.multiply(y));              // Commit to z and open it afterwards              return seq.seq(new CommitmentComputationMdsonic(commitmentSerializer, serializer.serialize(zj),                      noOfParties, localDrbg));            }).seq((seq, commitZjs) -> {              List<PlainT> elements = serializer.deserializeList(commitZjs);              PlainT sum = MdsonicUInt.sum(elements);              if (!sum.isZero()) {                throw new MaliciousException("Mac check failed");              }              authenticatedElements.clear();              openValues.clear();              return null;            });  }  /**   * Samples random coefficients for mac-check using joint source of randomness.   * Fixed bug: Invoke coin tossing protocol to get random seed real time.   */  private List<PlainT> sampleCoefficients(Drbg drbg, MdsonicCompUIntFactory<PlainT> factory,      int numCoefficients) {    List<PlainT> randomCoefficients = new ArrayList<>(numCoefficients);    for (int i = 0; i < numCoefficients; i++) {      byte[] bytes = new byte[factory.getHighBitLength() / Byte.SIZE];      drbg.nextBytes(bytes);      randomCoefficients.add(factory.createFromBytes(bytes));    }    return randomCoefficients;  }}