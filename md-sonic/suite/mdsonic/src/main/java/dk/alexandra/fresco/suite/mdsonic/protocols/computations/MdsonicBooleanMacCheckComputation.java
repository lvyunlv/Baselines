package dk.alexandra.fresco.suite.mdsonic.protocols.computations;import dk.alexandra.fresco.commitment.HashBasedCommitment;import dk.alexandra.fresco.framework.DRes;import dk.alexandra.fresco.framework.MaliciousException;import dk.alexandra.fresco.framework.builder.Computation;import dk.alexandra.fresco.framework.builder.numeric.ProtocolBuilderNumeric;import dk.alexandra.fresco.framework.network.serializers.ByteSerializer;import dk.alexandra.fresco.framework.util.Drbg;import dk.alexandra.fresco.framework.util.Pair;import dk.alexandra.fresco.suite.mdsonic.datatypes.*;import dk.alexandra.fresco.suite.mdsonic.resource.MdsonicResourcePool;import dk.alexandra.fresco.suite.mdsonic.resource.storage.MdsonicDataSupplier;import java.util.ArrayList;import java.util.List;import java.util.function.Function;import java.util.stream.Collectors;/** * Computation for performing batched mac-check on all currently opened, unchecked boolean values. */public class MdsonicBooleanMacCheckComputation<        HighT extends MdsonicUInt<HighT>,        LowT extends MdsonicUInt<LowT>,        PlainT extends MdsonicCompUInt<HighT, LowT, PlainT>, SecretP extends MdsonicGF<SecretP>>    implements Computation<Void, ProtocolBuilderNumeric> {  private final MdsonicDataSupplier<PlainT, SecretP> supplier;  private final MdsonicGFFactory<SecretP> factory;  private final List<MdsonicASBoolBoolean<SecretP>> authenticatedElements;  // ASS  private final List<Boolean> openValues;  private ByteSerializer<HashBasedCommitment> commitmentSerializer;  private final int noOfParties;  private final Drbg localDrbg;  private final Function<byte[], Drbg> jointDrbgSupplier;  private final int drbgByteLength;  /**   * Creates new {@link MdsonicBooleanMacCheckComputation}.   *   * @param toCheck authenticated elements and open values that must be checked   * @param resourcePool resources for running Spdz2k   */  public MdsonicBooleanMacCheckComputation(Pair<List<MdsonicASBoolBoolean<SecretP>>, List<Boolean>> toCheck,                                           MdsonicResourcePool<PlainT, SecretP> resourcePool,                                           final Function<byte[], Drbg> jointDrbgSupplier, final int drbgSeedBitLength) {    this.authenticatedElements = toCheck.getFirst();    this.openValues = toCheck.getSecond();    this.supplier = resourcePool.getDataSupplier();    this.factory = resourcePool.getBooleanFactory();    this.commitmentSerializer = resourcePool.getCommitmentSerializer();    this.noOfParties = resourcePool.getNoOfParties();    this.localDrbg = resourcePool.getLocalRandomGenerator();    this.jointDrbgSupplier = jointDrbgSupplier;    this.drbgByteLength = drbgSeedBitLength / 8;  // default 32 Bytes  }  @Override  public DRes<Void> buildComputation(ProtocolBuilderNumeric builder) {    SecretP macKeyShare = supplier.getSecretSharedKeyBoolean();    return builder            .seq(new CoinTossingComputation(drbgByteLength, commitmentSerializer, noOfParties, localDrbg))            .seq((seq, seed) -> {              Drbg jointDrbg = jointDrbgSupplier.apply(seed);              List<SecretP> randomCoefficients = sampleCoefficients(jointDrbg, factory, openValues.size());              SecretP b = MdsonicGF.innerProductWithBool(randomCoefficients, openValues);              List<SecretP> macShares = authenticatedElements.stream()                      .map(MdsonicASBoolBoolean::getMacShare)                      .collect(Collectors.toList());              macShares.add(macKeyShare);              randomCoefficients.add(b);              SecretP zj = factory.innerProduct(macShares, randomCoefficients);              // Commit to z and open it afterwards              return seq.seq(new CommitmentComputationMdsonic(commitmentSerializer, zj.getBits().toByteArray(),                      noOfParties, localDrbg));            }).seq((seq, commitZjs) -> {              List<SecretP> elements = new ArrayList<>(commitZjs.size());              for (byte[] element : commitZjs) {                elements.add(factory.createFromBytes(element));              }              SecretP sum = MdsonicGF.sum(elements);              if (!sum.isZero()) {                throw new MaliciousException("Mac check failed");              }              authenticatedElements.clear();              openValues.clear();              return null;            });  }  /**   * Samples random coefficients for mac-check using joint source of randomness.   * Fixed bug: Invoke coin tossing protocol to get random seed real time.   */  private List<SecretP> sampleCoefficients(Drbg drbg, MdsonicGFFactory<SecretP> factory,      int numCoefficients) {    List<SecretP> randomCoefficients = new ArrayList<>(numCoefficients);    for (int i = 0; i < numCoefficients; i++) {      byte[] bytes = new byte[factory.getBitLength() / Byte.SIZE];      drbg.nextBytes(bytes);      randomCoefficients.add(factory.createFromBytes(bytes));    }    return randomCoefficients;  }}