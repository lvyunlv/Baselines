package dk.alexandra.fresco.suite.mdsonic.protocols.computations;import dk.alexandra.fresco.commitment.HashBasedCommitment;import dk.alexandra.fresco.framework.DRes;import dk.alexandra.fresco.framework.MaliciousException;import dk.alexandra.fresco.framework.builder.Computation;import dk.alexandra.fresco.framework.builder.numeric.ProtocolBuilderNumeric;import dk.alexandra.fresco.framework.network.serializers.ByteSerializer;import dk.alexandra.fresco.framework.util.Drbg;import dk.alexandra.fresco.framework.util.Pair;import dk.alexandra.fresco.suite.mdsonic.datatypes.*;import dk.alexandra.fresco.suite.mdsonic.resource.MdsonicResourcePool;import dk.alexandra.fresco.suite.mdsonic.resource.storage.MdsonicDataSupplier;import java.nio.ByteBuffer;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.function.Function;import java.util.stream.Collectors;/** * Computation for performing batched mac-check on all currently opened, unchecked values boolean & arithmetic. */public class MdsonicMacCheckComputation<    HighT extends MdsonicUInt<HighT>,    LowT extends MdsonicUInt<LowT>,    PlainT extends MdsonicCompUInt<HighT, LowT, PlainT>, SecretP extends MdsonicGF<SecretP>>    implements Computation<Void, ProtocolBuilderNumeric> {  private final CheckFlag flag;  private final ByteSerializer<PlainT> serializer;  private final MdsonicDataSupplier<PlainT, SecretP> supplier;  private final MdsonicCompUIntFactory<PlainT> factory;  private final MdsonicGFFactory<SecretP> factoryBoolean;  private final List<MdsonicASIntArithmetic<PlainT>> authenticatedElements;  // ASS  private final List<MdsonicASBoolBoolean<SecretP>> authenticatedElementsBoolean;  // ASS  private final List<PlainT> openValues;  private final List<Boolean> openValuesBoolean;  private ByteSerializer<HashBasedCommitment> commitmentSerializer;  private final int noOfParties;  private final Drbg localDrbg;  private final Function<byte[], Drbg> jointDrbgSupplier;  private final int drbgByteLength;  /**   * Creates new {@link MdsonicMacCheckComputation}.   *   * @param toCheck authenticated elements and open values that must be checked   * @param resourcePool resources for running Spdz2k   */  public MdsonicMacCheckComputation(Pair<List<MdsonicASIntArithmetic<PlainT>>, List<PlainT>> toCheck,                                    Pair<List<MdsonicASBoolBoolean<SecretP>>, List<Boolean>> toCheckBoolean,                                    MdsonicResourcePool<PlainT, SecretP> resourcePool,                                    final Function<byte[], Drbg> jointDrbgSupplier, final int drbgSeedBitLength) {    if (toCheck == null && toCheckBoolean == null) {      throw new IllegalArgumentException("To Check channel can not be empty.");    } else if (toCheck == null) {      flag = CheckFlag.BOOLEAN;      this.authenticatedElements = null;      this.openValues = null;      this.authenticatedElementsBoolean = toCheckBoolean.getFirst();      this.openValuesBoolean = toCheckBoolean.getSecond();    } else if (toCheckBoolean == null) {      flag = CheckFlag.ARITHMETIC;      this.authenticatedElements = toCheck.getFirst();      this.openValues = toCheck.getSecond();      this.authenticatedElementsBoolean = null;      this.openValuesBoolean = null;    } else {      flag = CheckFlag.BOTH;      this.authenticatedElements = toCheck.getFirst();      this.openValues = toCheck.getSecond();      this.authenticatedElementsBoolean = toCheckBoolean.getFirst();      this.openValuesBoolean = toCheckBoolean.getSecond();    }    this.serializer = resourcePool.getPlainSerializer();    this.supplier = resourcePool.getDataSupplier();    this.factory = resourcePool.getFactory();    this.factoryBoolean = resourcePool.getBooleanFactory();    this.commitmentSerializer = resourcePool.getCommitmentSerializer();    this.noOfParties = resourcePool.getNoOfParties();    this.localDrbg = resourcePool.getLocalRandomGenerator();    this.jointDrbgSupplier = jointDrbgSupplier;    this.drbgByteLength = drbgSeedBitLength / 8;  }  @Override  public DRes<Void> buildComputation(ProtocolBuilderNumeric builder) {    PlainT macKeyShare = supplier.getSecretSharedKey();    SecretP macKeyShareBoolean = supplier.getSecretSharedKeyBoolean();    return builder            .seq(new CoinTossingComputation(drbgByteLength, commitmentSerializer, noOfParties, localDrbg))            .seq((seq, seed) -> {              Drbg jointDrbg = jointDrbgSupplier.apply(seed);              byte[] send;              if (flag == CheckFlag.BOTH) {                // Arithmetic                List<PlainT> randomCoefficients = sampleCoefficients(jointDrbg, factory, openValues.size());                PlainT y = MdsonicUInt.innerProduct(openValues, randomCoefficients);                List<PlainT> macShares = authenticatedElements.stream()                        .map(MdsonicASIntArithmetic::getMacShare)                        .collect(Collectors.toList());                PlainT mj = MdsonicUInt.innerProduct(macShares, randomCoefficients);                PlainT zj = mj.subtract(macKeyShare.multiply(y));                // Boolean                List<SecretP> randomCoefficientsBoolean = sampleCoefficientsBoolean(jointDrbg, factoryBoolean, openValuesBoolean.size());                SecretP b = MdsonicGF.innerProductWithBool(randomCoefficientsBoolean, openValuesBoolean);                List<SecretP> macSharesBoolean = authenticatedElementsBoolean.stream()                        .map(MdsonicASBoolBoolean::getMacShare)                        .collect(Collectors.toList());                macSharesBoolean.add(macKeyShareBoolean);                randomCoefficientsBoolean.add(b);                SecretP zjBoolean = factoryBoolean.innerProduct(macSharesBoolean, randomCoefficientsBoolean);                // arithmetic first                ByteBuffer buffer = ByteBuffer.allocate((factory.getCompositeBitLength() + factoryBoolean.getBitLength()) / 8);                buffer.put(serializer.serialize(zj));                buffer.put(zjBoolean.getBits().toByteArray());                send = buffer.array();              } else if (flag == CheckFlag.ARITHMETIC) {                // Arithmetic                List<PlainT> randomCoefficients = sampleCoefficients(jointDrbg, factory, openValues.size());                PlainT y = MdsonicUInt.innerProduct(openValues, randomCoefficients);                List<PlainT> macShares = authenticatedElements.stream()                        .map(MdsonicASIntArithmetic::getMacShare)                        .collect(Collectors.toList());                PlainT mj = MdsonicUInt.innerProduct(macShares, randomCoefficients);                PlainT zj = mj.subtract(macKeyShare.multiply(y));                send = serializer.serialize(zj);              } else {                // Boolean                List<SecretP> randomCoefficientsBoolean = sampleCoefficientsBoolean(jointDrbg, factoryBoolean, openValuesBoolean.size());                SecretP b = MdsonicGF.innerProductWithBool(randomCoefficientsBoolean, openValuesBoolean);                List<SecretP> macSharesBoolean = authenticatedElementsBoolean.stream()                        .map(MdsonicASBoolBoolean::getMacShare)                        .collect(Collectors.toList());                macSharesBoolean.add(macKeyShareBoolean);                randomCoefficientsBoolean.add(b);                SecretP zjBoolean = factoryBoolean.innerProduct(macSharesBoolean, randomCoefficientsBoolean);                send = zjBoolean.getBits().toByteArray();              }              // Commit to z and open it afterwards              return seq.seq(new CommitmentComputationMdsonic(commitmentSerializer, send, noOfParties, localDrbg));            }).seq((seq, commitZjs) -> {              if (flag == CheckFlag.BOTH) {                List<PlainT> elements = new ArrayList<>(commitZjs.size());                List<SecretP> elementsBoolean = new ArrayList<>(commitZjs.size());                for (byte[] element : commitZjs) {                  elements.add(serializer.deserialize(Arrays.copyOfRange(element, 0, (factory.getCompositeBitLength() / 8))));                  elementsBoolean.add(factoryBoolean.createFromBytes(Arrays.copyOfRange(element, (factory.getCompositeBitLength() / 8), element.length)));                }                PlainT sum = MdsonicUInt.sum(elements);                if (!sum.isZero()) {                  throw new MaliciousException("Mac check failed [Arithmetic]");                }                SecretP sumBoolean = MdsonicGF.sum(elementsBoolean);                if (!sumBoolean.isZero()) {                  throw new MaliciousException("Mac check failed [Boolean]");                }                authenticatedElements.clear();                openValues.clear();                authenticatedElementsBoolean.clear();                openValuesBoolean.clear();                return null;              } else if (flag == CheckFlag.ARITHMETIC) {                List<PlainT> elements = serializer.deserializeList(commitZjs);                PlainT sum = MdsonicUInt.sum(elements);                if (!sum.isZero()) {                  throw new MaliciousException("Mac check failed");                }                authenticatedElements.clear();                openValues.clear();                return null;              } else {                List<SecretP> elements = new ArrayList<>(commitZjs.size());                for (byte[] element : commitZjs) {                  elements.add(factoryBoolean.createFromBytes(element));                }                SecretP sum = MdsonicGF.sum(elements);                if (!sum.isZero()) {                  throw new MaliciousException("Mac check failed");                }                authenticatedElementsBoolean.clear();                openValuesBoolean.clear();                return null;              }            });  }  /**   * Samples random coefficients for mac-check using joint source of randomness.   * Fixed bug: Invoke coin tossing protocol to get random seed real time.   */  private List<PlainT> sampleCoefficients(Drbg drbg, MdsonicCompUIntFactory<PlainT> factory,      int numCoefficients) {    List<PlainT> randomCoefficients = new ArrayList<>(numCoefficients);    for (int i = 0; i < numCoefficients; i++) {      byte[] bytes = new byte[factory.getHighBitLength() / Byte.SIZE];      drbg.nextBytes(bytes);      randomCoefficients.add(factory.createFromBytes(bytes));    }    return randomCoefficients;  }  private List<SecretP> sampleCoefficientsBoolean(Drbg drbg, MdsonicGFFactory<SecretP> factory,                                           int numCoefficients) {    List<SecretP> randomCoefficients = new ArrayList<>(numCoefficients);    for (int i = 0; i < numCoefficients; i++) {      byte[] bytes = new byte[factory.getBitLength() / Byte.SIZE];      drbg.nextBytes(bytes);      randomCoefficients.add(factory.createFromBytes(bytes));    }    return randomCoefficients;  }}