package dk.alexandra.fresco.suite.spdz2k.protocols.computations;import dk.alexandra.fresco.commitment.HashBasedCommitment;import dk.alexandra.fresco.framework.DRes;import dk.alexandra.fresco.framework.MaliciousException;import dk.alexandra.fresco.framework.builder.Computation;import dk.alexandra.fresco.framework.builder.numeric.ProtocolBuilderNumeric;import dk.alexandra.fresco.framework.network.serializers.ByteSerializer;import dk.alexandra.fresco.framework.util.Drbg;import dk.alexandra.fresco.framework.util.Pair;import dk.alexandra.fresco.suite.spdz2k.datatypes.CompUInt;import dk.alexandra.fresco.suite.spdz2k.datatypes.CompUIntFactory;import dk.alexandra.fresco.suite.spdz2k.datatypes.Spdz2kSIntArithmetic;import dk.alexandra.fresco.suite.spdz2k.datatypes.UInt;import dk.alexandra.fresco.suite.spdz2k.resource.Spdz2kResourcePool;import dk.alexandra.fresco.suite.spdz2k.resource.storage.Spdz2kDataSupplier;import java.util.ArrayList;import java.util.List;import java.util.function.Function;import java.util.stream.Collectors;/** * Computation for performing batched mac-check on all currently opened, unchecked values. * * Fixed bugs in SPDZ2k version 2018. */public class Spdz2kMacCheckComputation<    HighT extends UInt<HighT>,    LowT extends UInt<LowT>,    PlainT extends CompUInt<HighT, LowT, PlainT>>    implements Computation<Void, ProtocolBuilderNumeric> {  private static int COUNT = 0;  private final ByteSerializer<PlainT> serializer;  private final Spdz2kDataSupplier<PlainT> supplier;  private final CompUIntFactory<PlainT> factory;  private final List<Spdz2kSIntArithmetic<PlainT>> authenticatedElements;  private final List<PlainT> openValues;  private ByteSerializer<HashBasedCommitment> commitmentSerializer;  private final int noOfParties;  private final Drbg localDrbg;  private final Function<byte[], Drbg> jointDrbgSupplier;  private final int drbgByteLength;  /**   * Creates new {@link Spdz2kMacCheckComputation}.   *   * @param toCheck authenticated elements and open values that must be checked   * @param resourcePool resources for running Spdz2k   */  public Spdz2kMacCheckComputation(Pair<List<Spdz2kSIntArithmetic<PlainT>>, List<PlainT>> toCheck,      Spdz2kResourcePool<PlainT> resourcePool,      final Function<byte[], Drbg> jointDrbgSupplier, final int drbgSeedBitLength) {    this.authenticatedElements = toCheck.getFirst();    this.openValues = toCheck.getSecond();    this.serializer = resourcePool.getPlainSerializer();    this.supplier = resourcePool.getDataSupplier();    this.factory = resourcePool.getFactory();    this.commitmentSerializer = resourcePool.getCommitmentSerializer();    this.noOfParties = resourcePool.getNoOfParties();    this.localDrbg = resourcePool.getLocalRandomGenerator();    this.jointDrbgSupplier = jointDrbgSupplier;    this.drbgByteLength = drbgSeedBitLength / 8;  }  @Override  public DRes<Void> buildComputation(ProtocolBuilderNumeric builder) {    PlainT macKeyShare = supplier.getSecretSharedKey();//    System.out.println("SPDZ2k Mac Check " + COUNT++ + " "+ openValues.size());    return builder            .seq(new CoinTossingComputation(drbgByteLength, commitmentSerializer, noOfParties, localDrbg))            .seq((seq, seed) -> {              Drbg jointDrbg = jointDrbgSupplier.apply(seed);              List<PlainT> randomCoefficients = sampleCoefficients(jointDrbg, factory, openValues.size());              PlainT y = UInt.innerProduct(openValues, randomCoefficients);              List<PlainT> macShares = authenticatedElements.stream()                      .map(Spdz2kSIntArithmetic::getMacShare)                      .collect(Collectors.toList());              PlainT mj = UInt.innerProduct(macShares, randomCoefficients);              PlainT zj = mj.subtract(macKeyShare.multiply(y));              // Commit to z and open it afterwards              return seq.seq(new CommitmentComputationSpdz2k(commitmentSerializer, serializer.serialize(zj),                      noOfParties, localDrbg));            }).seq((seq, commitZjs) -> {              List<PlainT> elements = serializer.deserializeList(commitZjs);              PlainT sum = UInt.sum(elements);              if (!sum.isZero()) {                throw new MaliciousException("Mac check failed");              }              authenticatedElements.clear();              openValues.clear();              return null;            });  }  /**   * Samples random coefficients for mac-check using joint source of randomness.   * Fixed bug: Invoke coin tossing protocol to get random seed real time.   */  private List<PlainT> sampleCoefficients(Drbg drbg, CompUIntFactory<PlainT> factory,      int numCoefficients) {    List<PlainT> randomCoefficients = new ArrayList<>(numCoefficients);    for (int i = 0; i < numCoefficients; i++) {      byte[] bytes = new byte[factory.getHighBitLength() / Byte.SIZE];      drbg.nextBytes(bytes);      randomCoefficients.add(factory.createFromBytes(bytes));    }    return randomCoefficients;  }}